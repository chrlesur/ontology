[
  {
    "name": "element.go",
    "content": "package ontology\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"strings\"\r\n)\r\n\r\n// OntologyElement représente un élément unique dans l'ontologie\r\ntype OntologyElement struct {\r\n\tName      string\r\n\tType      string\r\n\tPositions []int\r\n}\r\n\r\n// NewOntologyElement crée un nouvel OntologyElement\r\nfunc NewOntologyElement(name, elementType string) *OntologyElement {\r\n\treturn \u0026OntologyElement{\r\n\t\tName:      name,\r\n\t\tType:      elementType,\r\n\t\tPositions: []int{},\r\n\t}\r\n}\r\n\r\n// AddPosition ajoute une nouvelle position à l'élément\r\nfunc (e *OntologyElement) AddPosition(position int) {\r\n\te.Positions = append(e.Positions, position)\r\n}\r\n\r\n// SetPositions remplace toutes les positions existantes par un nouveau slice\r\nfunc (e *OntologyElement) SetPositions(positions []int) {\r\n\te.Positions = positions\r\n}\r\n\r\n// String retourne une représentation en chaîne de caractères de l'élément\r\nfunc (e *OntologyElement) String() string {\r\n\tposStr := strings.Trim(strings.Join(strings.Fields(fmt.Sprint(e.Positions)), \",\"), \"[]\")\r\n\treturn fmt.Sprintf(\"%s|%s@%s\", e.Name, e.Type, posStr)\r\n}\r\n\r\n// Ontology représente une collection d'éléments d'ontologie\r\ntype Ontology struct {\r\n\tElements []*OntologyElement\r\n}\r\n\r\n// NewOntology crée une nouvelle instance d'Ontology\r\nfunc NewOntology() *Ontology {\r\n\treturn \u0026Ontology{\r\n\t\tElements: []*OntologyElement{},\r\n\t}\r\n}\r\n\r\n// AddElement ajoute un nouvel élément à l'ontologie\r\nfunc (o *Ontology) AddElement(element *OntologyElement) {\r\n\to.Elements = append(o.Elements, element)\r\n}\r\n\r\n// GetElementByName recherche un élément par son nom\r\nfunc (o *Ontology) GetElementByName(name string) *OntologyElement {\r\n\tfor _, element := range o.Elements {\r\n\t\tif element.Name == name {\r\n\t\t\treturn element\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n",
    "size": 1737,
    "modTime": "2024-10-22T09:43:51.5204518+02:00",
    "path": "element.go"
  },
  {
    "name": "enrich.go",
    "content": "package ontology\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\t\"path/filepath\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/chrlesur/Ontology/internal/i18n\"\r\n\t\"github.com/chrlesur/Ontology/internal/logger\"\r\n\t\"github.com/chrlesur/Ontology/internal/pipeline\"\r\n\t\"github.com/spf13/cobra\"\r\n)\r\n\r\nvar (\r\n\toutput           string\r\n\tformat           string\r\n\tllm              string\r\n\tllmModel         string\r\n\tpasses           int\r\n\trdf              bool\r\n\towl              bool\r\n\trecursive        bool\r\n\texistingOntology string\r\n)\r\n\r\n// enrichCmd represents the enrich command\r\nvar enrichCmd = \u0026cobra.Command{\r\n\tUse:   \"enrich [input]\",\r\n\tShort: i18n.Messages.EnrichCmdShortDesc,\r\n\tLong:  i18n.Messages.EnrichCmdLongDesc,\r\n\tArgs:  cobra.ExactArgs(1),\r\n\tRunE: func(cmd *cobra.Command, args []string) error {\r\n\t\tinput := args[0]\r\n\t\tlog := logger.GetLogger()\r\n\t\tlog.Info(i18n.Messages.StartingEnrichProcess)\r\n\r\n\t\t// Utiliser le chemin absolu pour l'entrée\r\n\t\tabsInput, err := filepath.Abs(input)\r\n\t\tif err != nil {\r\n\t\t\treturn fmt.Errorf(\"error getting absolute path: %w\", err)\r\n\t\t}\r\n\r\n\t\t// Déterminer le nom de fichier de sortie si non spécifié\r\n\t\tif output == \"\" {\r\n\t\t\toutput = generateOutputFilename(absInput, owl, rdf)\r\n\t\t} else {\r\n\t\t\t// Si output est spécifié, s'assurer qu'il est absolu\r\n\t\t\toutput, err = filepath.Abs(output)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn fmt.Errorf(\"error getting absolute path for output: %w\", err)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tp, err := pipeline.NewPipeline()\r\n\t\tif err != nil {\r\n\t\t\treturn fmt.Errorf(\"%s: %w\", i18n.Messages.ErrorCreatingPipeline, err)\r\n\t\t}\r\n\r\n\t\tp.SetProgressCallback(func(info pipeline.ProgressInfo) {\r\n\t\t\tswitch info.CurrentStep {\r\n\t\t\tcase \"Starting Pass\":\r\n\t\t\t\tlog.Info(\"Starting pass %d of %d\", info.CurrentPass, info.TotalPasses)\r\n\t\t\tcase \"Segmenting\":\r\n\t\t\t\tlog.Info(\"Segmenting input into %d parts\", info.TotalSegments)\r\n\t\t\tcase \"Processing Segment\":\r\n\t\t\t\tlog.Debug(\"Processing segment %d of %d\", info.ProcessedSegments, info.TotalSegments)\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\terr = p.ExecutePipeline(filePath, outputPath, passes, existingOntology, ontology)\r\n\t\tif err != nil {\r\n\t\t\treturn fmt.Errorf(\"%s: %w\", i18n.Messages.ErrorExecutingPipeline, err)\r\n\t\t}\r\n\r\n\t\tlog.Info(i18n.Messages.EnrichProcessCompleted)\r\n\t\tlog.Info(\"File processed: %s, output: %s\", absInput, output)\r\n\t\treturn nil\r\n\t},\r\n}\r\n\r\nfunc init() {\r\n\trootCmd.AddCommand(enrichCmd)\r\n\r\n\tenrichCmd.Flags().StringVar(\u0026output, \"output\", \"\", i18n.Messages.OutputFlagUsage)\r\n\tenrichCmd.Flags().StringVar(\u0026format, \"format\", \"\", i18n.Messages.FormatFlagUsage)\r\n\tenrichCmd.Flags().StringVar(\u0026llm, \"llm\", \"\", i18n.Messages.LLMFlagUsage)\r\n\tenrichCmd.Flags().StringVar(\u0026llmModel, \"llm-model\", \"\", i18n.Messages.LLMModelFlagUsage)\r\n\tenrichCmd.Flags().IntVar(\u0026passes, \"passes\", 1, i18n.Messages.PassesFlagUsage)\r\n\tenrichCmd.Flags().BoolVar(\u0026rdf, \"rdf\", false, i18n.Messages.RDFFlagUsage)\r\n\tenrichCmd.Flags().BoolVar(\u0026owl, \"owl\", false, i18n.Messages.OWLFlagUsage)\r\n\tenrichCmd.Flags().BoolVar(\u0026recursive, \"recursive\", false, i18n.Messages.RecursiveFlagUsage)\r\n\tenrichCmd.Flags().StringVar(\u0026existingOntology, \"existing-ontology\", \"\", i18n.Messages.ExistingOntologyFlagUsage)\r\n}\r\n\r\nfunc processDirectory(dirPath string) error {\r\n\treturn filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif info.IsDir() {\r\n\t\t\tif !recursive \u0026\u0026 path != dirPath {\r\n\t\t\t\treturn filepath.SkipDir\r\n\t\t\t}\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\treturn processFile(path)\r\n\t})\r\n}\r\n\r\nfunc processFile(filePath string) error {\r\n\toutputPath := output\r\n\tif outputPath == \"\" {\r\n\t\t// Générer le nom de fichier de sortie dans le même répertoire que le fichier d'entrée\r\n\t\tdir := filepath.Dir(filePath)\r\n\t\tbaseName := filepath.Base(filePath)\r\n\t\tbaseName = strings.TrimSuffix(baseName, filepath.Ext(baseName))\r\n\r\n\t\tvar extension string\r\n\t\tif owl {\r\n\t\t\textension = \".owl\"\r\n\t\t} else if rdf {\r\n\t\t\textension = \".rdf\"\r\n\t\t} else {\r\n\t\t\textension = \".tsv\"\r\n\t\t}\r\n\r\n\t\toutputPath = filepath.Join(dir, baseName+extension)\r\n\t}\r\n\r\n\tp, err := pipeline.NewPipeline()\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"%s: %w\", i18n.Messages.ErrorCreatingPipeline, err)\r\n\t}\r\n\r\n\tontology := ontology.NewOntology() // Créer une nouvelle ontologie\r\n\r\n\t// Passer le chemin de sortie à ExecutePipeline\r\n\terr = p.ExecutePipeline(filePath, outputPath, passes, existingOntology, ontology)\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"%s: %w\", i18n.Messages.ErrorExecutingPipeline, err)\r\n\t}\r\n\r\n\tlog.Info(fmt.Sprintf(\"File processed: %s, output: %s\", filePath, outputPath))\r\n\treturn nil\r\n}\r\n\r\nfunc generateOutputFilename(input string, owl, rdf bool) string {\r\n\tdir := filepath.Dir(input)\r\n\tbaseName := filepath.Base(input)\r\n\tbaseName = strings.TrimSuffix(baseName, filepath.Ext(baseName))\r\n\r\n\tvar extension string\r\n\tif owl {\r\n\t\textension = \".owl\"\r\n\t} else if rdf {\r\n\t\textension = \".rdf\"\r\n\t} else {\r\n\t\textension = \".tsv\"\r\n\t}\r\n\r\n\treturn filepath.Join(dir, baseName+extension)\r\n}\r\n",
    "size": 4884,
    "modTime": "2024-10-22T10:22:53.5218841+02:00",
    "path": "enrich.go"
  },
  {
    "name": "logger.go",
    "content": "package ontology // ou le nom du package approprié\r\n\r\nimport (\r\n    \"github.com/chrlesur/Ontology/internal/logger\"\r\n)\r\n\r\nvar log = logger.GetLogger()",
    "size": 150,
    "modTime": "2024-10-20T17:29:08.5359463+02:00",
    "path": "logger.go"
  },
  {
    "name": "root.go",
    "content": "package ontology\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"os\"\r\n\r\n\t\"github.com/chrlesur/Ontology/internal/config\"\r\n\t\"github.com/chrlesur/Ontology/internal/i18n\"\r\n\t\"github.com/chrlesur/Ontology/internal/logger\"\r\n\t\"github.com/spf13/cobra\"\r\n)\r\n\r\nvar (\r\n\tcfgFile string\r\n\tdebug   bool\r\n\tsilent  bool\r\n)\r\n\r\n// rootCmd represents the base command when called without any subcommands\r\nvar rootCmd = \u0026cobra.Command{\r\n\tUse:   \"ontology\",\r\n\tShort: i18n.GetMessage(\"RootCmdShortDesc\"),\r\n\tLong:  i18n.GetMessage(\"RootCmdLongDesc\"),\r\n}\r\n\r\n// Execute adds all child commands to the root command and sets flags appropriately.\r\n// This is called by main.main(). It only needs to happen once to the rootCmd.\r\nfunc Execute() {\r\n\terr := rootCmd.Execute()\r\n\tif err != nil {\r\n\t\tos.Exit(1)\r\n\t}\r\n}\r\n\r\nfunc init() {\r\n\tcobra.OnInitialize(initConfig)\r\n\r\n\trootCmd.PersistentFlags().StringVar(\u0026cfgFile, \"config\", \"\", i18n.GetMessage(\"ConfigFlagUsage\"))\r\n\trootCmd.PersistentFlags().BoolVar(\u0026debug, \"debug\", false, i18n.GetMessage(\"DebugFlagUsage\"))\r\n\trootCmd.PersistentFlags().BoolVar(\u0026silent, \"silent\", false, i18n.GetMessage(\"SilentFlagUsage\"))\r\n\r\n\trootCmd.Run = rootCmd.HelpFunc()\r\n}\r\n\r\n// initConfig reads in config file and ENV variables if set.\r\nfunc initConfig() {\r\n\tif cfgFile != \"\" {\r\n\t\t// Set the config file path if specified\r\n\t\tos.Setenv(\"ONTOLOGY_CONFIG_PATH\", cfgFile)\r\n\t}\r\n\r\n\t// This will load the config from file and environment variables\r\n\tcfg := config.GetConfig()\r\n\r\n\t// Validate the config\r\n\tif err := cfg.ValidateConfig(); err != nil {\r\n\t\tfmt.Printf(\"Error in configuration: %v\\n\", err)\r\n\t\tos.Exit(1)\r\n\t}\r\n\r\n\tlog := logger.GetLogger()\r\n\r\n\t// Initialize logger based on debug and silent flags\r\n\tif debug {\r\n\t\tlog.SetLevel(logger.DebugLevel)\r\n\t} else if silent {\r\n\t\tlog.SetLevel(logger.ErrorLevel)\r\n\t} else {\r\n\t\tlogLevel := logger.ParseLevel(cfg.LogLevel)\r\n\t\tlog.SetLevel(logLevel)\r\n\t}\r\n\r\n\tlog.Info(i18n.GetMessage(\"InitializingApplication\"))\r\n}\r\n",
    "size": 1919,
    "modTime": "2024-10-21T20:31:04.012075+02:00",
    "path": "root.go"
  }
]